I"”$<video autoplay="" loop="" muted="" width="800">
<source type="video/webm" src="/videos/aerials.webm" />
Your browser does not support the video element.
</video>

<p>One of the most useful and impressive maneuvers in Rocket League
is the aerial hit, where a car changes its orientation and feathers
the boost in such a way that it intercepts the ball. Although it takes
most people a while to develop intuition about how to aerial successfully,
we will see that it is a very simple mechanic to implement for a bot.
In particular, the following description will allow us to 
quantitatively determine:</p>

<ul>
  <li>if the car can aerial to a certain point in a given amount of time</li>
  <li>how much boost it would take to reach that point</li>
  <li>how to control the car to carry out the aerial maneuver</li>
</ul>

<h2 id="problem-statement">Problem Statement</h2>

<p>Let \(\boldsymbol{c}(t)\) denote the position of our car, and 
\(\boldsymbol{f}(t)\) be the unit vector in the direction 
the car faces, both in world coordinates.</p>

<p>Additionally, we will take \(B(t), g\) to denote the accelerations
due to boost and gravity (respectively), and \(\boldsymbol{P}\)
will be our target location.</p>

<p>For clarity, we will assume that the car has already left the ground, 
so that we can focus our attention on just the dynamics of aerials.</p>

<h2 id="kinematics">Kinematics</h2>

<p>The carâ€™s motion is described by an ordinary differential equation
that includes contributions due to boost and gravity, and initial conditions:</p>

\[\ddot{\boldsymbol{c}}(t) = B(t) \; \boldsymbol{f}(t) + g \; \boldsymbol{z}, \quad 
\dot{\boldsymbol{c}}(0) = \boldsymbol{v}_o, \quad
\boldsymbol{c}(0) = \boldsymbol{x}_o, \quad
\boldsymbol{f}(0) = \boldsymbol{f}_o\]

<p>where \(\boldsymbol{z}\) is the unit vector in the z-direction. We would
like to find those functions \(B(t), \boldsymbol{f}(t)\) that produce the
trajectory that intersects our target at the prescribed time, \(\Delta t\):</p>

\[\boldsymbol{c}(\Delta t) = \boldsymbol{P}\]

<p>Because the original differential equation is separable, we can
directly integrate twice to get</p>

\[\boldsymbol{c}(t) = \boldsymbol{x}_o + \boldsymbol{v}_o \; t + \frac{1}{2} \; g \; t^2 \; \boldsymbol{z} + 
\int_0^t \int_0^\tau B(\sigma) \; \boldsymbol{f}(\sigma) \; d\sigma d\tau\]

<p>Now, we demand that the intersection condition is satisfied:</p>

\[\boldsymbol{c}(\Delta t) = \boldsymbol{P} = \boldsymbol{x}_o + \boldsymbol{v}_o \; \Delta t + \frac{1}{2} \; g \; \Delta t^2 \; \boldsymbol{z} + 
\int_0^{\Delta t} \int_0^\tau B(\sigma) \; \boldsymbol{f}(\sigma) \; d\sigma d\tau\]

<p>Rearrange terms to group all the things we can control on the left side, and everything
else on the right:</p>

\[\int_0^{\Delta t} \int_0^\tau B(\sigma) \; \boldsymbol{f}(\sigma) \; d\sigma d\tau = 
\boldsymbol{P} - \boldsymbol{x}_o - \boldsymbol{v}_o \; \Delta t - \frac{1}{2} \; g \; \Delta t^2 \; \boldsymbol{z}\]

<p>Although this expression is very general, it isnâ€™t immediately obvious how to use it to determine
our controls. What if we assumed that the car did the following:</p>

<ol>
  <li>take some amount of time, \(0 &lt; t &lt; T\), to turn the car so it faces a certain direction \(\boldsymbol{f}^*\), without boosting</li>
  <li>keep facing that direction, and boost with some constant acceleration for \(T &lt; t &lt; \Delta t\)</li>
</ol>

<p>More rigorously: \(B(t) = \begin{cases}
  0 &amp; 0 &lt; t &lt; T \\
  B_0 &amp; T &lt; t &lt; \Delta t
\end{cases}, \qquad \boldsymbol{f}(t) = \begin{cases}
  q(t) &amp; 0 &lt; t &lt; T \\
  \boldsymbol{f}^* &amp; T &lt; t &lt; \Delta t
\end{cases}\)</p>

<p>If we put these expressions into the double integral above and simplify, we get:</p>

\[\frac{1}{2} B_0 \; (T - \Delta t)^2 \boldsymbol{f}^* = 
\boldsymbol{P} - \boldsymbol{x}_o - \boldsymbol{v}_o \; \Delta t - \frac{1}{2} \; g \; \Delta t^2 \; \boldsymbol{z}\]

<p>Dividing through by some constants gives us the working equation:</p>

\[B_0 \boldsymbol{f}^* = \frac{2}{(T - \Delta t)^2} \bigg(
\boldsymbol{P} - \boldsymbol{x}_o - \boldsymbol{v}_o \; \Delta t - \frac{1}{2} \; g \; \Delta t^2 \; \boldsymbol{z}
\bigg) = \bar{\boldsymbol{A}}\]

<h2 id="interpretation">Interpretation</h2>

<p>Upon closer inspection, we see that each side of the working equation above has the dimension of acceleration.
This means that we can interpret the right-hand side as the acceleration needed to arrive at target
\(\boldsymbol P\) in time \(\Delta t\).</p>

<p>This means that \(B_0 = \|\bar{\boldsymbol{A}}\|\) and 
\(\displaystyle \boldsymbol{f}^* = \frac{\bar{\boldsymbol{A}}}{\|\bar{\boldsymbol{A}}\|}\)</p>

<blockquote>
  <p>How can we tell if \(P\) is reachable by this maneuver?</p>
</blockquote>

<p>Simply: check if \(B_0\) is smaller than the carâ€™s actual boost acceleration (~1000 u/s^2).
If the maneuver requires an acceleration larger than what the car can achieve, we cannot
get there in time.</p>

<blockquote>
  <p>How much boost will I need to complete this maneuver?</p>
</blockquote>

<p>If we know the average acceleration, \(B_0\), and how long we will be boosting \((\Delta t - T),\)
then we know how long we will have to hold the boost button down, so we know how much boost it will take.</p>

<blockquote>
  <p>How do I feather boost to produce the right average acceleration?</p>
</blockquote>

<p>Keep a running counter for the boost, and do something like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Aerial</span><span class="p">:</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">boost_counter</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">B_max</span> <span class="o">=</span> <span class="mf">1000.0</span>
    <span class="p">...</span>

  <span class="k">def</span> <span class="nf">get_output</span><span class="p">():</span>

    <span class="p">...</span>

    <span class="c1"># compute A, B_0
</span>    <span class="n">A</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">B_0</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    
    <span class="n">use_boost</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># set the boost in such a way that its duty cycle
</span>    <span class="c1"># approximates the desired average boost ratio
</span>    <span class="n">use_boost</span> <span class="o">-=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">boost_counter</span><span class="p">)</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">boost_counter</span> <span class="o">+=</span> <span class="n">B_0</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">B_max</span>
    <span class="n">use_boost</span> <span class="o">+=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">boost_counter</span><span class="p">)</span>
    
    <span class="bp">self</span><span class="p">.</span><span class="n">controls</span><span class="p">.</span><span class="n">boost</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">use_boost</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="p">...</span>

</code></pre></div></div>

<blockquote>
  <p>How do I make my car turn to the correct direction, \(\boldsymbol{f}^*\)?</p>
</blockquote>

<p>Stay tuned for an aerial turn controller, that also provides estimates for how
long it takes to perform the turn.</p>

<blockquote>
  <p>How do I freestyle with my bot?</p>
</blockquote>

<p>To make contact with the ball, you only need to face the front of the car in the correct
direction, meaning you can keep rolling as much as you want once the front direction is aligned.
Additionally, you can boost more than the average acceleration to make the necessary
course correction in less time. Once the necessary acceleration is close to zero, 
your car is already on an intersection trajectory, so you can stop boosting and just 
spin around in any direction you want.</p>

<h2 id="summary">Summary</h2>

<p>To hit an aerial, use the working equation below to find the acceleration magnitude and direction
required to make contact.</p>

\[\bar{\boldsymbol{A}} = \frac{2}{(T - \Delta t)^2} \bigg(
\boldsymbol{P} - \boldsymbol{x}_o - \boldsymbol{v}_o \; \Delta t - \frac{1}{2} \; g \; \Delta t^2 \; \boldsymbol{z}
\bigg)\]

<p>\(B_0 = \|\bar{\boldsymbol{A}}\|\) and 
\(\displaystyle \boldsymbol{f}^* = \frac{\bar{\boldsymbol{A}}}{\|\bar{\boldsymbol{A}}\|}\)</p>

<p>If the directions are aligned (i.e. \(\boldsymbol{f} \approx \boldsymbol{f}^*\)), feather boost to produce the right
acceleration, \(B_0\), otherwise perform an aerial turn to align the car with the appropriate direction, 
\(\boldsymbol{f}^*\).</p>
:ET