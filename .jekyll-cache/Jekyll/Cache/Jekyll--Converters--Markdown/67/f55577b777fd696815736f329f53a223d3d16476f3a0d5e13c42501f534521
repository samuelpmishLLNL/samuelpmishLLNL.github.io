I"f0<p>This is a continuation of a <a href="/notes/RocketLeague/aerial_control/">previous post</a>,
to demonstrate how to solve the inverse problem of determining
user input from trajectories.</p>

<h2 id="problem-statement">Problem Statement</h2>

<p>Say we know that, at a particular instant in time, a user was
controlling a vehicle in the air (without being hit by another
car, or air dodging). Is it possible to use information about the car’s
dynamic state to determine what inputs the users issued?</p>

<p>Let’s take a look: from the previous post, we have the following update
procedure for the angular velocity:</p>

\[\boldsymbol{\omega}(t + \Delta t) := 
\boldsymbol{\omega}(t) + \boldsymbol\tau \Delta t\]

<p>If we knew what the beginning and end step values of
\(\boldsymbol{\omega}\) were, then we know what
\(\boldsymbol{\tau}\) must have been:</p>

\[\boldsymbol{\tau} = \frac{
\boldsymbol{\omega}(t + \Delta t) - 
\boldsymbol{\omega}(t)
}{\Delta t}\]

<p>furthermore, by using our expression for \(\boldsymbol{\tau}\)
in the other post, we can say that</p>

\[\boldsymbol{\tau} = 
\boldsymbol{\Theta}(t) \; (
\boldsymbol{T} \; \boldsymbol{u} + D(\boldsymbol{u}) \;
\boldsymbol{\Theta}(t)^\top \; \boldsymbol{\omega(t)}
)\]

<p>where \(\boldsymbol{u}\) is the vector of user inputs
(roll, pitch, yaw) that we seek. The definition of
\(\boldsymbol{D}(\boldsymbol{u})\) involves absolute
values of components of \(\boldsymbol{u}\), making the
equations nonlinear:</p>

\[\begin{alignedat}{2}
T_r \, &amp; u_r                &amp;= \tau_r - D_r \, \omega_r \\ 
T_p \, &amp; u_p - D_p \, |u_p| &amp;= \tau_p - D_p \, \omega_p \\ 
T_y \, &amp; u_y - D_y \, |u_y| &amp;= \tau_y - D_y \, \omega_y
\end{alignedat}
\;\; \text{where} \;\;
\tilde{\boldsymbol{\tau}} = \begin{bmatrix}
\tau_r \\ \tau_p \\ \tau_y
\end{bmatrix} = \boldsymbol{\Theta}^\top \boldsymbol{\tau},
\;\;
\tilde{\boldsymbol{\omega}} = \begin{bmatrix}
\omega_r \\ \omega_p \\ \omega_y
\end{bmatrix} = \boldsymbol{\Theta}^\top \boldsymbol{\omega}\]

<p>Thankfully, they are decoupled, so they can be solved individually:</p>

<p>Roll:
\(u_r = \displaystyle \frac{\tau_r - D_r \; \omega_r}{T_r}\)</p>

<p>Pitch:
\(u_p = \displaystyle \frac{\tau_p - D_p \; \omega_p}{T_p + \text{sgn}(\tau_p - D_p \; \omega_p) \omega_p D_p}\)</p>

<p>Yaw:
\(u_y = \displaystyle \frac{\tau_y - D_y \; \omega_y}{T_y - \text{sgn}(\tau_y - D_y \; \omega_y) \omega_y D_y}\)</p>

<p>Where \(\text{sgn}\)() is the <a href="https://en.wikipedia.org/wiki/Sign_function">signum function</a>. 
Ideally, these values will always be in the range (-1, 1), but to get the best admissible
input in weird cases, do the following as well:</p>

\[\begin{aligned}
u_r &amp;\coloneqq u_r \; \min(1.0, \frac{1}{|u_r|}) \\
u_p &amp;\coloneqq u_p \; \min(1.0, \frac{1}{|u_p|}) \\
u_y &amp;\coloneqq u_y \; \min(1.0, \frac{1}{|u_y|}) \\
\end{aligned}\]

<h2 id="dealing-with-a-maximum-angular-speed">Dealing with a Maximum Angular Speed</h2>

<p>If the norm of angular velocity exceeds 5.5, Rocket League 
scales it back down, until it is 5.5. How does this affect our
ability to guess the inputs of a trajectory?</p>

<p>In short, this means there will be more than one net torque
\(\boldsymbol\tau\) that produces identical end-step angular
velocities. As a result, there can be cases where there are
infinitely many possible inputs that produce the same 
aerial trajectory. The procedure described above will still
work, and will find the inputs that produce the torque 
of minimum magnitude that yields the appropriate end-step
angular velocity!</p>

<h2 id="example-problem">Example Problem</h2>

<p>These examples show how well the recovered user
input (dashed lines) compares to the exact values (solid
lines). The trace in red is the norm of the angular velocity–
note that when it hits 5.5, the inputs do not coincide.
However, it is the case that the exact inputs and the
recovered would still have the same effect on the car.</p>

<p><img src="/images/RocketLeague/aerial_control_inverse.png" alt="" /></p>

<p>An example where angular velocities do not clip shows
almost exact agreement:</p>

<p><img src="/images/RocketLeague/aerial_control_inverse_roll.png" alt="" /></p>

<h2 id="possible-implementation">Possible Implementation</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">float</span> <span class="n">T_r</span> <span class="o">=</span> <span class="o">-</span><span class="mf">36.07956616966136</span><span class="p">;</span> <span class="c1">// torque coefficient for roll</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">T_p</span> <span class="o">=</span> <span class="o">-</span><span class="mf">12.14599781908070</span><span class="p">;</span> <span class="c1">// torque coefficient for pitch</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">T_y</span> <span class="o">=</span>   <span class="mf">8.91962804287785</span><span class="p">;</span> <span class="c1">// torque coefficient for yaw</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">D_r</span> <span class="o">=</span>  <span class="o">-</span><span class="mf">4.47166302201591</span><span class="p">;</span> <span class="c1">// drag coefficient for roll</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">D_p</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.798194258050845</span><span class="p">;</span> <span class="c1">// drag coefficient for pitch</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">D_y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.886491900437232</span><span class="p">;</span> <span class="c1">// drag coefficient for yaw</span>

<span class="kt">float</span> <span class="nf">sgn</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">return</span> <span class="p">(</span><span class="mf">0.0</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">vec3</span> <span class="nf">aerial_inputs</span><span class="p">(</span>
    <span class="n">vec3</span> <span class="n">omega_start</span><span class="p">,</span> 
    <span class="n">vec3</span> <span class="n">omega_end</span><span class="p">,</span>
    <span class="n">mat3x3</span> <span class="n">theta_start</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// net torque in world coordinates</span>
  <span class="n">vec3</span> <span class="n">tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega_end</span> <span class="o">-</span> <span class="n">omega_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span><span class="p">;</span> 

  <span class="c1">// net torque in local coordinates</span>
  <span class="n">tau</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">theta_start</span><span class="p">),</span> <span class="n">tau</span><span class="p">);</span>

  <span class="c1">// beginning-step angular velocity, in local coordinates</span>
  <span class="n">vec3</span> <span class="n">omega_local</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">theta_start</span><span class="p">),</span> <span class="n">omega_start</span><span class="p">);</span>

  <span class="n">vec3</span> <span class="n">rhs</span><span class="p">{</span>
    <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">D_r</span> <span class="o">*</span> <span class="n">omega_local</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">tau</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">D_p</span> <span class="o">*</span> <span class="n">omega_local</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">tau</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">D_y</span> <span class="o">*</span> <span class="n">omega_local</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
  <span class="p">};</span>

  <span class="c1">// user inputs: roll, pitch, yaw</span>
  <span class="n">vec3</span> <span class="n">u</span><span class="p">{</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">T_r</span><span class="p">,</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">T_p</span> <span class="o">+</span> <span class="n">sgn</span><span class="p">(</span><span class="n">rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">omega_local</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">D_p</span><span class="p">),</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">T_y</span> <span class="o">-</span> <span class="n">sgn</span><span class="p">(</span><span class="n">rhs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">omega_local</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">D_y</span><span class="p">)</span>
  <span class="p">};</span>

  <span class="c1">// ensure that values are between -1 and +1 </span>
  <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fmin</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fabs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
  <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fmin</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fabs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
  <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fmin</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fabs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>

  <span class="k">return</span> <span class="n">u</span><span class="p">;</span> 

<span class="p">}</span>
</code></pre></div></div>

<p>An example file to verify correctness can be found 
<a href="/notes/RocketLeague/rollpitchyaw_example.csv">here</a>.
The 9 columns of this file correspond to (in order)</p>
<ul>
  <li>3 components of angular velocity (world coordinates),</li>
  <li>3 rotators (in 16 bit integer representation from RL),</li>
  <li>3 user inputs (roll, pitch, yaw)</li>
</ul>
:ET